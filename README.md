# C# Data Structures and Algorithms Fundamentals
This repository is a comprehensive repository of essential data structures and algorithms implemented in C#, with clean, well-documented code and clear organization. This project demonstrates proficiency in core programming concepts such as arrays, linked lists, stacks, queues, trees, graphs, recursion, sorting, and searching algorithms. Ideal for technical interviews and foundational understanding, it reflects a strong grasp of algorithmic thinking and software engineering principles using .NET technologies.

### 01 - Frequency Counters
The Frequency Counter pattern uses objects or hash tables to count occurrences of values, enabling efficient comparisons and data validations. It is particularly useful in problems involving anagram detection, duplicates, and value matching across arrays or strings. This folder introduces foundational logic used in optimizing nested loops and improving time complexity.

### 02 - Multiple Pointers
The Multiple Pointers strategy involves creating pointers or indices that move toward each other or in parallel to solve problems with minimal space complexity. This technique is ideal for sorted data and is commonly used in problems like finding pairs that sum to a specific value, checking subsequences, or counting unique values.

### 03 - Sliding Window
The Sliding Window technique is perfect for problems involving arrays or strings where you need to examine a subset of elements, such as the maximum sum of a subarray or the shortest subarray length. It reduces nested iterations and enhances performance by reusing computations while shifting the window across the dataset.

### 04 - Recursion
This section introduces the basics of Recursion, a technique where functions call themselves to solve problems. Initial examples cover stack trace behavior and basic recursive functions like factorials and summing ranges, forming a foundation for understanding more complex recursive patterns.

### 05 - Recursion II
Building on the fundamentals, Recursion II explores classic recursive problems such as computing powers, Fibonacci numbers, and summing arrays. These examples help reinforce how breaking problems down into smaller subproblems can yield elegant and reusable solutions.

### 06 - Recursion III
This folder delves into intermediate recursive challenges, such as reversing strings, checking for palindromes, and flattening nested arrays. These problems introduce more complex recursive logic and demonstrate how recursion can traverse and transform structured data.

### 07 - Recursion IV
Recursion IV focuses on recursive solutions for real-world data transformations, like capitalizing strings, summing nested objects, or converting number values in an object tree. These examples showcase how recursion is applied in manipulating nested or hierarchical data structures.

### 08 - Searching Algorithms
This folder covers key Searching Algorithms, starting with linear search for unsorted data and advancing to binary and string search techniques for sorted or textual data. These algorithms are critical for efficient data retrieval and appear frequently in interview problems.

### 09 - Sorting Algorithms
The Sorting Algorithms section covers classic techniques such as bubble sort, insertion sort, selection sort, merge sort, quicksort, and radix sort. It also includes helper methods and variations that demonstrate how divide-and-conquer and comparison-based sorting work under the hood.

### 10 - Singly Linked List
Here, you'll find a full implementation of a Singly Linked List, including methods like push, pop, shift, unshift, get, set, insert, remove, and reverse. These operations illustrate how data structures operate in low-level memory management scenarios.

### 11 - Doubly Linked List
Doubly Linked Lists expand on singly linked lists by supporting bidirectional traversal, improving certain operations like deletion or backward iteration. This folder demonstrates the implementation and benefits of having both next and prev references in list nodes.

### 12 - Stacks & Queues
This folder implements Stacks (LIFO) and Queues (FIFO), two fundamental abstract data types. They are crucial in problems involving backtracking, scheduling, undo operations, and breadth-first traversal in trees and graphs.

### 13 - Binary Search Tree
A Binary Search Tree (BST) is a hierarchical structure that enables fast lookup, insertion, and deletion of ordered data. This folder includes common BST operations and traversal strategies like DFS, BFS, and balance checking, often seen in system design questions.

### 14 - Binary Heap
The Binary Heap is a specialized tree-based structure used primarily for priority queues. This section shows how to maintain the heap property during insertion and removal, including max-heaps and priority-based processing used in algorithms like Dijkstra’s.

### 15 - Hash Tables
This section focuses on Hash Tables, a powerful tool for constant-time lookups and insertions. You’ll see how to implement and optimize hash functions, manage key collisions, and retrieve keys or values, which are foundational for many data-driven applications.

### 16 - Graphs
Graphs represent networks of connected nodes and edges. This folder introduces basic graph structures and traversal techniques such as DFS (recursive and iterative) and BFS, which are applicable to real-world problems like navigation, recommendation systems, and social networks.

### 17 - Dijkstra’s Algorithm
This section provides an in-depth implementation of Dijkstra’s Algorithm for finding the shortest path in weighted graphs. It includes priority queue optimizations and demonstrates key graph algorithm concepts frequently used in route planning and game development.

### 18 - Dynamic Programming
Dynamic Programming (DP) is a technique for solving complex problems by breaking them down into overlapping subproblems and storing intermediate results. This folder includes both memoization and tabulation approaches for problems like Fibonacci numbers and the coin change problem.

### 19 - Tries
The Trie (Prefix Tree) is a tree-like structure optimized for prefix-based searching and autocompletion. This folder explores operations like adding, finding, and removing words, as well as building autocomplete suggestions—a key component in text processing and predictive typing.
